import groovy.json.JsonSlurper

// https://qiita.com/cypher256/items/f3db6bba86692c3c7733
// @see org.gradle.api.tasks.wrapper.Wrapper, org.gradle.util.DistributionLocator
wrapper {
    distributionType = Wrapper.DistributionType.ALL
    doFirst {
        def versionService = new URL('https://services.gradle.org/versions/current')
        gradleVersion = new JsonSlurper().parseText(versionService.text).version
        println "gradleVersion: ${gradleVersion}"
    }
}


task prepareDirectories(description: 'create source directories') {
    doLast {
        project.sourceSets.each { sourceSet ->
            sourceSet.allSource.srcDirs.each { dir ->
                _mkdir(dir)
                def packageDir = new File(dir, project.group.replace('.', '/'))
                _mkdir(packageDir)
            }
        }

        if (project.plugins.hasPlugin('war')) {
            _mkdir(webAppDir)
        }
    }
}

def _mkdir(dir) {
    if (!dir.exists()) {
        assert dir.mkdirs()
        logger.info('mkdir: {}', dir)
    } else {
        logger.info('already exist: {}', dir)
    }
}

def sourceEncoding = 'UTF-8'
tasks.withType(SourceTask).each {
    // ':compileGroovy', ':compileJava', 'compileTestGroovy', ':compileTestJava', ':groovydoc', ':javadoc'
    def p1 = 'options'
    def p2 = 'encoding'
    if (it.hasProperty(p1)) {
        if (it[p1].hasProperty(p2)) {
            logger.info('{} has \'{}.{}\' property', it, p1, p2)
            it[p1][p2] = sourceEncoding
        } else {
            logger.info('{} has no \'{}.{}\' property', it, p1, p2)
        }
    } else {
        logger.info('{} has no \'{}\' property', it, p1)
    }
}
